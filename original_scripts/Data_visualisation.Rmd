---
title: "R Tutorial - Data visualtisation"
output: html_document
---

```{r}
options(max.print=50)
```

# 4. Data visualisation

Graphical representations of your data can help to see structures and depict comparisons. There are many ways to visualise data and R comes with quite powerful and versatile tools to create all kinds of plots. 

Base R (meaning R without any additional packages installed) already has some functions to plot graphics from data, but these functions are very rudimentary and are not nice to work with. Luckily, there is a package called `ggplot2`, which unifies many different types of visualisations under one umbrella, using consistent syntax. Here we will only scratch the surface but I highly recommend that you familiarise yourself more with it. This is a long but very good video that explains the principles of `ggplot2`: https://www.youtube.com/live/h29g21z0a68?si=DdodJAcWyM0EwCI8.

We could install and load `ggplot2` separately, but you all should have `tidyverse` installed, which is a collection of several packages. `ggplot2` is one of them, and so are some others that we will use in this exercise. So all we need to do is to load `tidyverse` and we will have access to all these helpful functions, including `ggplot2.` For more info on `tidyverse` and its contained packages (including useful cheat sheets), see: https://www.tidyverse.org/

Along the way of this exercise, there will be a few small tasks that usually only require you to change one or two parameters of the previous command. At the end of the exercise, there are several tasks to recreate the plots we made on a different data set. You will see the plot that you are supposed to create underneath the task. Look at it so you have an idea what you should do. Below the plot you will find the solution. No peaking!

```{r}
library(tidyverse)
```

How exactly you want to visualise your data depends on the data itself and the the properties you wish to highlight. The visualisations we will be looking at in this exercise are

- Scatter plots. Draw points from pairs of values on an x-y plane. Good to see potential correlations.
- Bar plots. Good to compare single values in different categories (e.g. counts).
- (Stacked bar plots. Good to compare ratios inside categories.)
- Box plots. Good to visualise distributions of values.
- Histograms. Another way to visualise a distribution.
- Density plots. Yet another way to visualise distributions.
- Violin plots. Somewhat a way to combine a box plot with a histogram.

## 4.1 Load in the data set and explore it a bit

For this exercise we will be using a the `iris` data set, which is included in R.

Load an R-internal data set and create a dataframe called `iris`.
```{r}
data(iris)
```

Look at the structure of the dataframe:
```{r}
str(iris)
```

Look at the first 6 rows of the dataframe:
```{r}
head(iris)
```

View the entire dataframe in a separate tab:
```{r}
View(iris)
```

Let's see how many measurements of each species we have:
```{r}
table(iris$Species)
mean(iris$Sepal.Length) # Not very useful, because it's averaging over all species.
```

With `tidyverse` loaded, instead of "printing" data to the console or assigning it to a new variable, you can also "pipe" it into a function by using `%>%`. The output of that function can then be piped into the next function and so on. This makes it easier to keep track of your code while avoiding to define too many variables. 

**Tip: Build a pipe step by step to make sure that the output of one step is what it should be before you pipe it into the next function. Remember that when you are working in a script, hitting CTRL-ENTER will execute the whole pipe where your cursor is at that time, which may span over several lines. If you want to execute parts of a pipe (or of any code) first mark the text and then hit CTRL-ENTER. If you want to assign the outcome of the pipe to a variable, do that after you have built the pipe and you are happy with the outcome.**

Let's build this first pipe step by step together. Later I will only give you the complete pipe but I strongly recommend that you always build them step by step so you know what is going on and can easier trouble-shoot.

We start by calling the original data set, and confirm that it is what we think it is.
```{r}
iris
```

Now we pipe the dataframe into a function, in this case `group_by()`.
```{r}
iris %>%
  group_by(Species)
```

Visually not much has changed, but we get the additional info that we now have a group with 3 members in the Species column. Following calculations will now be done separately on each group instead of the entire dataframe or column.

So let's pipe this into the next function: `summarise()`. This function will create a new dataframe, with columns that we can define. Since we are giving it a grouped dataframe, `summarise()` will create a row for each member of the group, i.e. for each species.
```{r}
iris %>%
  group_by(Species) %>%
  summarise(mean_sepal_length = mean(Sepal.Length), 
            mean_sepal_width = mean(Sepal.Width),
            mean_petal_length = mean(Sepal.Length),
            mean_petal_width = mean(Petal.Width)
  )
```

This is looking good. So let's assign the output of this pipe to a new variable. We will use it further down.
```{r}
mean_flower_sizes <- iris %>%
  group_by(Species) %>%
  summarise(mean_sepal_length = mean(Sepal.Length),
            mean_sepal_width = mean(Sepal.Width),
            mean_petal_length = mean(Sepal.Length),
            mean_petal_width = mean(Petal.Width)
            )
```

## 4.2 Scatter plots
Maybe the simplest type of plot is a scatter plot. Given pairs of values, it will draw them as points on a plane.

For this example, let's filter down the `iris` data set to only include the virginica species.
```{r}
only_virginica <- iris %>%
  filter(Species=="virginica")
```

And now let's create a first plot. We call `ggplot()` and state which data we want to plot and `aes()`, the "aesthetics", (where we define what should be on the x and what on the y axis). After the `ggplot()` call, we add "geometries" using a `+`. In this case, we add a `geom_point()` but we can also add more or different geometries, such as `geom_smooth()` (to draw a curve that follows the points) or `geom_line()` (to connect the points with lines). Play around with adding or removing them!
```{r}
ggplot(only_virginica, aes(x=Sepal.Length, y=Sepal.Width)) +
  geom_point() + 
  geom_smooth() + 
  geom_line() 
```

You should now see a plot appearing in the bottom-right corner of RStudio. You can resize that window or click on Zoom to open a new window that only contains this plot. You can save the plot to a file by clicking on Export. 

It's also possible to store a plot into a variable
```{r}
p <- ggplot(only_virginica, aes(x=Sepal.Length, y=Sepal.Width)) +
  geom_point()
```

To visualise the plot again, simply call the variable:
```{r}
p
```

If you have stored the plot in a variable, you can also save it using the function `ggsave()`. You will have to adjust the `filename` parameter to point to a folder on your computer.

```{r}
ggsave(filename="~/PhD/Teaching/example_plot.pdf", plot=p, width=7, height=5)
```

**Task: Make a scatter plot that shows the sepal length of Iris versicolor on the x axiis and its petal length on the y axis.**
![](data_vis_task_1.png)
```{r}
# Solution:
only_versicolor <- iris %>%
  filter(Species=="versicolor")

# I assign the plot to a variable so it doesn't appear twice in the HTML file. You don't have to do that.
p <- ggplot(only_versicolor, aes(x=Sepal.Length, y=Petal.Length)) +
  geom_point()
```

During the course, someone asked how to plot the coordinates next to each point. This is how I would do it: We first need an additional column in our dataframe. Inside a pipe we can use the `mutate()` function for this. To generate the text from the values of `Sepal.Length` and `Sepal.Width` we can use `paste()`. By default, `paste()` will put an empty space between the elements it combines. Let's use a slash as a separator instead by specifying `sep="/"`. Remember to build the pipe step by step so you confirm that the new column is created and contains what you want before assigning the pipe to a new variable.
```{r}
virginica_with_coords <- only_virginica %>%
  mutate(coodinates_SL_SW = paste(Sepal.Length, Sepal.Width, sep="/"))
```

Now we can plot this new data frame. In the `aes()` call we add a `label` parameter, assigning the `coodinates_SL_SW` column to it that we just created. We also have to add a `geom_text()` and change the vertical and horizontal adjustment, so we don't plot over the points.
```{r}
ggplot(virginica_with_coords, aes(x=Sepal.Length, y=Sepal.Width, label=coodinates_SL_SW)) +
  geom_point() +
  geom_text(hjust=0, vjust=0)
```

It's a bit messy and would need some effort to make look good. You could change the font size of the labels and/or the colors or install an additional package, e.g. `ggrepel`, that is made for this purpose. Making plots look pretty, not only functional, often takes the most time, but I think you get the idea, so we will leave it like this for now.

## 4.3 Bar plots
### 4.3.1 Simple bar plots
Earlier we created this `mean_flower_sizes` dataframe, containing the mean leaf lengths. Have another look at it and then filter it down to only include the mean sepal length.
```{r}
m_sep_len <- mean_flower_sizes %>%
    select(c(Species, mean_sepal_length)) # c() is necessary, because we specify more than one column.
```

And now make a bar chart with this filtered-down data set.
```{r}
ggplot(m_sep_len, aes(x=Species, y=mean_sepal_length)) +
  geom_col()
```

### 4.3.2 Grouped bar plots

Some features of `ggplot()` work best if the data is in a long (or so-called tidy) format, so we will have to pivot the table by all columns except the Species column. Take a moment to understand what `pivot_longer()` does. The tables before and after the function call contain the same information, but it is presented differently.
```{r}
mean_flower_sizes %>%
  pivot_longer(-Species)
```


Now that we know how to pivot our data into a long format, we can plot a grouped bar plot. For this we add a `fill` parameter to the `aes()` call and `position="dodge"` to `geom_col()`. If you leave out the latter, you would get a stacked bar plot, which doesn't make a lot of sense here, but try it out! Also, you can pipe data directly into `ggplot()`! When you do that, you don't need to specify the data to plot anymore, `ggplot()` will automatically use the data that is coming through the pipe. When you are done with the plot, assign it to a variable called `p`.
```{r}
p <- mean_flower_sizes %>%
  pivot_longer(-Species) %>% 
  ggplot(aes(x=name, y=value, fill=Species)) +
  geom_col(position='dodge')
p # After assigning the plot to a variable you can display it again by calling the variable.
```

After we assigned the plot to a variable, we can still continue to change it by calling the variable and adding things using a `+`. 

For example, we could add an arbitrary horizontal line using `geom_hline()`. Add the parameters of this function one by one to see what they do.
```{r}
p + geom_hline(yintercept=1, color="yellow", linewidth=1, linetype='dashed')
```

We can also add a title or change the axis to a log scale. Add the following lines of code one by one to see what each of them is doing but remember that a command should not end with a `+`. So type a line without the `+` at the end, execute it, look what happened, add the `+` and the next line withouth the `+` at the end, execute it and so on.
```{r}
  p + ggtitle("Size of Iris flowers") + # This will add a title
  theme(plot.title = element_text(size=14, face="bold", hjust=0.5)) + # Make the title bigger and centered
  scale_y_continuous(trans="log10") + # Change the y axis to a log scale
  coord_cartesian(ylim=c(-0.4,3)) # Limit the y axis to an arbitrary range
```

**Task: Create a grouped bar chart where the groups are the species and the bars in the groups are the mean leaf lengths for that species.**
![](data_vis_task_2.png)

```{r}
# Solution:
p <- mean_flower_sizes %>%
  pivot_longer(-Species) %>% 
  ggplot(aes(x=Species, y=value, fill=name)) +
  geom_col(position='dodge')
```

## 4.4 Box plots
So far we have visualised mean values. That's nice but we lose the information about how the data was distributed. This is where box plots come in handy. 

To start with an easy example, let's filter down our `iris` data set once more and plot a single box.
```{r}
iris %>%
  filter(Species=="setosa") %>% 
  select(Petal.Length) %>% 
  ggplot(aes(y=Petal.Length)) +
  geom_boxplot()
```

This is what you need to know about boxplots:

- The width of the box has no meaning.
- The bottom border of the box denotes the *1st quartile*, i.e. 25% of the data points are below this border, 75% are above.
- The horizontal line inside the box denotes the *median* (2nd quartile), i.e. half of the data points are below this line, half are above.
-  The top border of the box denotes the *3rd quartile*, i.e. 75% of the data points are below this border, 25% are above.
- The height of the box, so the range between the 1st and the 3rd quartile, is called the *interquartile range* and contains 50% of the data points.
- The vertical lines above and below the box are called whiskers. They can be as long as 1.5 times the interquartile range but only extend to the highest/lowest data point inside this maximum length.
- Data points outside the maximum length of the whiskers are plotted individually and are potential outliers.


Let's go back to the original dataframe and make a new long table, this time on all the measurements. We want to make a plot with 4 groups of boxes, one for each type of measurement and in each group 3 boxes, one for each species. In other words, we would like to group the box plot as we have grouped the bar plot. Unsurprisingly, we code this in the same way as well. See what happens if you leave out the `fill` parameter!
```{r}
# Let's save the long (or "tidy") table into a new variable, because we will need it later again:
tidy_iris <- iris %>%
  pivot_longer(-Species)

ggplot(tidy_iris, aes(x=name, y=value, fill=Species)) +
    geom_boxplot()
```

**Task: Make a box plot that only contains the values from the versicolor species. **
![](data_vis_task_3.png)
```{r}
# Solution
tidy_iris %>%
  filter(Species=="versicolor") %>%
  ggplot(aes(x=Species, y=value, fill=name)) +
  geom_boxplot()
```

## 4.5 Histograms
Histograms can give you a more detailed impression of a distribution. Histograms put the values that you give it into bins and then display how many values are in each bin. That's essentially all there is to it! You can manipulate the resolution by changing the width of the bins either directly by setting the `binwidth` parameter, or implicitly but setting the number of `bins` with the bins parameter. Play around with this parameter!

Let's start with a filtered-down example.
```{r}
iris %>%
  filter(Species=="setosa") %>% 
  select(Sepal.Length) %>%
  ggplot(aes(x=Sepal.Length)) + # Only x is required. y is calculated by the geometry.
  geom_histogram(binwidth = 0.1)
```

Similarly to what we did with the box plot, we can also add several histograms simply by specifying a fill. 

**Note: When you add several histograms, the counts inside the bins from the different histograms will add up! This is typically not what we want, so we will have to tell the geometry to not add up anything and use the values as they are by using the parameter `position="identity"`. But then we have the problem that some parts of the histograms will be hidden behind others. To make them transparent, we can choose an `alpha` parameter of less than 1.**
```{r}
iris %>%
  ggplot(aes(x=Petal.Length, fill=Species)) +
  geom_histogram(binwidth = 0.08, position="identity", alpha=0.8)
```

## 4.6 Density plots

Density plots have a similar purpose as histograms. But instead of bars representing bins, a density plot will draw a smooth curve. Let's create one and discuss what we are seeing. To make a density plot, you can use the exact same input as for the histogram, but add a different geometry.

```{r}
iris %>%
  ggplot(aes(x=Petal.Length, fill=Species)) +
  geom_density(alpha=0.5)
```
If you understand a histogram you will have an intuitive understanding of what a density plot is. To be more precise about what is happening, imagine all the Petal.Length values lined up on the x axis. Then a curve is drawn around each data point. The density plot is then made by adding up all the curves. Areas where many data points are close to each other will have more to add and therefore reach higher on the y axis, while areas with low density will be lower on the y axis.

**Note that, unlike with histograms, the y axis in a density plot does not represent count data anymore.**

As we have seen before, you can also add different geometries into the same plot. So if you wanted, you could plot a histogram and a density plot together.
```{r}
iris %>%
  ggplot(aes(x=Petal.Length, fill=Species)) +
  geom_histogram(binwidth = 0.08, alpha=0.8, position="identity") +
  geom_density(alpha=0.5)
```

## 4.7 Violin plots

Now that you know what a box plot and a density plot is, you can easily understand violin plots. They are essentially a combination of both! For a violin plot, you can use the same input as for a box plot and simply change the geometry.
```{r}
ggplot(tidy_iris, aes(x=name, y=value, fill=Species)) +
  geom_violin() 
```

This plot is a bit unclear. The violins are very slim and it's hard to see what's going on. So let me show you another feature of `ggplot2`, by which you can arrange different groups of your plots in so-called facets. Simply add `facet_wrap()` to your plot and tell it by which column of your data the plot should be divided. The `draw_quantiles` parameter lets you draw horizontal lines into the violins at different quantiles. You can choose which and how many quantiles you want to have, here I used the first, second and third quartile, similar to a box plot. The `scales="free_x"` allows the facets to have different x axes, which in this case means that it prevents empty spaces. As always, see how the plot looks like without these parameters!
```{r}
ggplot(tidy_iris, aes(x=name, y=value, fill=Species)) +
  geom_violin(draw_quantiles=c(0.25, 0.5, 0.75)) + 
  facet_wrap(~name, scales="free_x")
```

As you can see, a violin plot resembles a box plot but now, the width of the violin has a meaning. It is essentially a density plot drawn inside each box. In fact, it's the same density plot drawn symmetrically to the left and right, resulting in this violin-like shape. Also, violin plots typically don't have whiskers or separately drawn outliers.

## 4.8 Practice!

Now you have seen most of the basic plots! I encourage you to practice what you learnt on a different data set. Below you will find a few exercises that you can do in your own time. Like with the small tasks before, I will embed the end result underneath the task so you know what you should achieve. The solutions will be below the plot but I highly recommend that you try your best to figur it out yourself!

The `PlantGrowth` data set contains the weight of some plants after 2 different treatments and in a control group.
```{r}
data(PlantGrowth)
```

Explore the data! Use `View()`, `str()`, `head()` and so on to get an idea of what you are dealing with. 

As you will see, the `PlantGrowth` dataframe is kind of in a long format. That's ok for almost all plots in this exercise but I will also provide you with a wide table, which you will need for the scatter plot:
```{r}
PlantGrowth_wide <- PlantGrowth %>%
  mutate(measurement = rep(1:10, 3)) %>%
  pivot_wider(names_from = group, values_from = weight)
```

### 4.8.1 Scatter plot 
Show the weight for treatment 1 on the x axis and the weight for treatment 2 on the y axis.

![](data_vis_ex_scatter_plot.png)
```{r}
# Solution:
p <- PlantGrowth_wide %>%
  ggplot(aes(x=trt1, y=trt2)) +
  geom_point() +
  ggtitle("4.8.1 - Scatter plot")
```

### 4.8.2 Barpot 
Plot the median plant growth for the different treatments and the control

![](data_vis_ex_barplot.png)

```{r}
# Solution:
p <- PlantGrowth %>%
  group_by(group) %>%
  summarise(median_growth = median(weight)) %>%
  ggplot(aes(x=group, y=median_growth)) +
  geom_col() +
  ggtitle("4.8.2 - Barplot")
```

### 4.8.3 Boxplot
Plot plant growth for the different treatments and the control.

![](data_vis_ex_boxplot.png)
```{r}
# Solution
p <- PlantGrowth %>%
  ggplot(aes(x=group, y=weight)) +
  geom_boxplot() + 
  ggtitle("4.8.3 - Boxplot")
```

### 4.8.4 Histogram
Plot the plant growth for the different treatments and the control (set the binwidth to 0.15).

![](data_vis_ex_histogram.png)
```{r}
# Solution:
p <- PlantGrowth %>%
  ggplot(aes(x=weight, fill=group)) +
  geom_histogram(position="identity", alpha=0.8, binwidth = 0.15) +
  ggtitle("4.8.4 - Histogram")
```

### 4.8.5 Density plot
Plot the plant growth for the different treatments and the control (set `color` instead of `fill` and don't set an `alpha`):

![](data_vis_ex_density_plot.png)
```{r}
# Solution:
p <- PlantGrowth %>%
  ggplot(aes(x=weight, color=group)) +
  geom_density() +
  ggtitle("4.8.5 - Density plot")
```

### 4.8.6 Violin plot
Plot the plant growth for the different treatments and the control (add all quartiles, no facet needed, add a `geom_point()`!)

![](data_vis_ex_violin_plot.png)
```{r}
p <- PlantGrowth %>%
  ggplot(aes(x=group, y=weight)) +
  geom_violin(draw_quantiles=c(0.25,0.5,0.75)) +
  geom_point() +
  ggtitle("4.8.6 - Violin plot")
```

**The end!**