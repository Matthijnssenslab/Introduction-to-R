---
title: "R Tutorial - Documentation"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Congrats! You've made it to the end of the R workshop! We have prepared this documentation for you, where you will find all the code we wrote during the workshop. Don't hesitate to go through it again at your own pace to make sure you understand everything ;-) 

Have fun with R!

Celes, Lander, Lisa, Mustafa and Nikolas

## 1. R Data Types

R has 5 basic data types that are :  
* character  
* numeric  
* integer  
* complex  
* logical  

### 1.1. Character  
A character is a text (or string) value typed between single ('') or double ("") quotes. 

```{r}
#To assign a value to a variable, you need to use the command: variable <- value
my_character <- "hello there"

#To print out the data type of a variable, you can use the function typeof() or class()
typeof(my_character)
```
### 1.2. Numeric  
A numeric is a decimal value (also called double-precision real value). 

```{r}
my_numeric <- 3.14
typeof(my_numeric)
```
### 1.3. Integer  
Integers are a subset of the numeric data type. Integers are whole values and are specified by the letter "L".

```{r}
my_integer <- 24
typeof(my_integer)
```
```{r}
my_integer <- 24L
typeof(my_integer)
```
### 1.4. Complex  
A complex number is a value with real and imaginary parts.

```{r}
my_complex <- 2+5i
typeof(my_complex)
```
### 1.5. Logical  
A logical is a boolean value (*TRUE* or *FALSE*). Be careful: Logicals are case sensitive. Writing *True* or *true* does not work.

```{r}
my_logical <- TRUE
typeof(my_logical)
```
## 2. Arithmetic with R
R can also be used as a calculator. R follows the standard order of priority and accepts the following operators:  
Addition: `+`  
Subtraction: `-`  
Multiplication: `*`  
Division: `/`  
Exponentiation: `^`  

```{r}
x <- 4+2*6
y <- 2^10
    
#To print out the value of a variable, you can use the function print() or just type the name of the variable
print(x)
y
```
## 3. R Data Structures
R’s basic data structures include the vector, list, matrix, data frame, and factors. Some of these structures require that all members be of the same data type (e.g. vectors, matrices) while others permit multiple data types (e.g., lists, data frames).

### 3.1. Vectors  
A vector is the simplest and most used data structure in R. It is a collection of data values of the same type (e.g., all numerics, characters, logicals...). Vectors are called often atomic vectors as they can only accommodate one type of R data.      
The easiest way to create a vector is to use the c() function that *concatenates* several given elements.  

```{r}
x <- c("blue", "green", "orange", "red", "yellow") #vector of characters
y <- c(44, 33, 22, 11) #vector of numerics
z <- c(TRUE, FALSE, FALSE) #vector of logicals
```

Let's have a look at the attributes of the vectors we just created:  

```{r}
class(x) #to print the type of elements in the vector
length(y) #to print the length of the vector
str(z) #to print the structure/content of the vector
```
When combining vectors of different data types, one data type will outrule the other one(s). This conversion between types is called “coercion”.   
When R converts the mode of storage based on its content, it is referred to as “implicit coercion”.  
R applies the following rule is: Character > Numeric > Integer > Logical.

```{r}
i <- c(x, y)
print(i)
class(i)
```
You can also control the coercion using as.\<data_type>(). This is referred to as "explicit coercion".

```{r}
j <- as.character(y)
print(j)
class(j)
```
Manipulation of vectors: adding elements, using missing data, retrieving elements...  

**Adding an element**

```{r}
x <- c(x, "white")
x

y <- c(55, y)
y
```
**Manipulating missing data**  
  
Missing values are  represented  by  `NA`  (Not  Available)  without  quotes.  `NA`  represents  both  missing character and numeric data. NA values have a class also, so there are integer NA, character NA, etc... Impossible values (e.g., dividing by zero) are represented by the symbol `NaN` (Not A Number).  
`is.na()` is used to test objects if they are NA  
`is.nan()` is used to test for NaN  

```{r}
temp <- c(23, 24, 25, 18, 19, NA, NA)
is.na(temp)
```
**Retrieving elements**  

```{r}
x[2] #to retrieve the 2nd element of the vector
x[1:3] #to retrieve the elements between the 1st and 3rd position
x[c(2,4)] #to retrieve the 2nd and 4th elements
x[x!="green"] #to retrieve all the elements which are not equal to "green"
y[y>30] #to retrieve all the elements which value is above 30
```
### 3.2. Matrices  

Matrices are vectors with two *dimensions*: the number of rows and the number of columns. The dimension attribute is itself an integer vector of length 2 (nrow, ncol). Matrices can hold numeric, character or logical values. The elements in a matrix all have the same data type.

```{r}
m <- matrix(nrow = 2, ncol = 3) #to create a matrix with 2 rows and 3 columns
m #to print the content of matrix m. The matrix will be filled with NAs if no values given.
dim(m) #to print the dimensions of the matrix m
```
Matrices are build *column-wise* so the entries will be put first in all the rows of column 1 before moving to column 2.  

```{r}
stud1 <- c(14,15)
stud2 <- c(10,11)
stud3 <- c(19,17)

grades <- matrix(c(stud1, stud2, stud3), nrow = 2, ncol = 3)
grades
```
You can change the names of the columns and the rows using colnames() and rownames().  

```{r}
rownames(grades) <- c("test A", "test B")
colnames(grades) <- c("student 1", "student 2", "student 3")
grades
```
You can add columns or rows to a matrix using cbind() or rbind(), respectively.  
```{r}
stud4 <- c(13, 15)
grades <- cbind(grades, stud4)
grades

colnames(grades)[4] <- "student 4" #to replace the name of the 4th column
grades
```
### 3.3. Lists

Unlike vectors, the contents of a list are not restricted to a single type and can encompass any mixture of data types. Lists are sometimes called generic vectors, because the elements of a list can by of any type of R object. This property makes them fundamentally different from atomic vectors.

You can create lists using list(). 
```{r}
l <- list("blue", 23, TRUE)
```
An empty list of the required length can be created using vector().
```{r}
l_empty <- vector("list", length = 5)
```
You can name the components of a list.
```{r}
features <- list(eyecolor = c("blue", "brown", "black"), age = c(18,23,25), siblings = c(FALSE, TRUE, TRUE))
```
You can also name the components of a list using names(). 
```{r}
names(l) <- c("eyecolor", "age", "siblings")
```

**Retrieving components of a list**  
To retrieve a component of a list, you can use [[]], using either the position of the element in the list or the name of that component. You can also use the "$" sign followed by the name of the component.

```{r}
features[[1]]
features[["age"]]
features$siblings
```
### 3.4. Data Frames

You will mostly work with data frames if you want to import and analyze datasets in R. A data frame is a special type of list where every component of the list has same length. Unlike matrices, data frames can store different classes of objects in each column. R has some built-in data frames that you can use to practice some manipulations. Let's have a look at the `iris` dataset.

![](iris_image.png)

```{r}
data(iris)
#view(iris) #opens a new tab containing the iris data frame
```

Here are some useful functions for data frames:

To show the first 6 rows: `head()`  
To show the last 6 rows: `tail()`  
To print the dimensions of data frame (i.e. number of rows and number of columns): `dim()`  
To print the number of rows: `nrow()`  
To print the number of columns: `ncol()`  
To print the structure of a data frame (i.e. name, type and preview of data in each column): `str()`  
To show the names attribute for a data frame: `names()` or `colnames()`  
To show the class of each column in the data frame: `sapply(<dataframe>, class)`  
  
Let's have a look at our dataset:
```{r}
dim(iris) 
colnames(iris)
str(iris)
```
**Retrieving elements**

To retrieve an element based on its column and row numbers
```{r}
iris[2,3] #to retrieve the second element in the 3rd column
iris[1:3, "Sepal.Width"] #to retrieve the first 3 sepal widths
```
To select one column from the data frame
```{r, eval=FALSE}
iris[,4] #based on the column number
```


```{r, eval=FALSE}
iris[,"Petal.Width"] #based on the column name
```


```{r}
iris$Petal.Width #based on the column name
```

**Filtering the rows of a data frame**
```{r}
iris[iris$Species == "setosa",] #subsets the flowers (rows) that belong to "setosa" species.
```


```{r, eval=FALSE}
iris[iris$Species %in% c("setosa", "virginica"),] #subsets the flowers (rows) that belong to "setosa" or the "virginica" species.
```


```{r}
iris[iris$Species == "setosa" | iris$Species == "virginica",] #the pipe '|' means 'OR'
iris[iris$Petal.Length > 6,] #subset the flowers (rows) for which the petal length is above 6cm.
iris[iris$Species == "virginica" & iris$Sepal.Length >= 7.5,] #the symbol '&' means 'AND'
```
**Operations on the columns of a data frame**
```{r}
iris$Ratio.Sepal.Petal <- iris$Sepal.Length/iris$Petal.Length #creates a new column to store the ratio of the sepal legnth to the petal length
iris$Av.Sepal.Length[iris$Species=="setosa"] <- mean(iris$Sepal.Length[iris$Species=="setosa"]) 
iris$Av.Sepal.Length[iris$Species=="versicolor"] <- mean(iris$Sepal.Length[iris$Species=="versicolor"]) 
iris$Av.Sepal.Length[iris$Species=="virginica"] <- mean(iris$Sepal.Length[iris$Species=="virginica"])
```

You can also use a loop to perform the last 3 commands at once:
```{r}
species <- unique(iris$Species)

# Use a for loop to calculate and assign the average sepal length for each species
for (s in species) {
  iris$Av.Sepal.Length[iris$Species == s] <- mean(iris$Sepal.Length[iris$Species == s])
}
```


**Export a data frame**
You can save a data frame as a .tsv (tab-separated values) file or a .csv (comma-separated values) file using the `write.table()` function.  
```{r}
write.table(iris, file = "iris_R.tsv", sep = "\t", row.names = TRUE, col.names = TRUE)
write.table(iris, file = "iris_R.csv", sep = ";", row.names = TRUE, col.names = TRUE)
```

**Import a dataset as a data frame**
You can import a dataset as a data frame using the `read.table()` function.  
```{r}
data <- read.table("iris_R.tsv", sep = "\t", header = TRUE)
```

